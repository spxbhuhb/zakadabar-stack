/*
 * Copyright Â© 2020-2021, Simplexion, Hungary and contributors. Use of this source code is governed by the Apache 2.0 license.
 */
package zakadabar.android.jdbc.sqlite

import java.sql.*
import java.util.*

class SQLDroidStatement(private var sqldroidConnection: SQLDroidConnection) : Statement {

    companion object {
        val selectPattern = Regex("(?m)(?s)\\s*(SELECT|PRAGMA|EXPLAIN QUERY PLAN).*")
    }

    private val db: SQLiteDatabase
    private var rs: SQLDroidResultSet? = null
    protected var sqlBatch = StringBuffer()
    private var maxRows: Int? = null

    /** The update count.  We don't know this, but need to respond in such a way that:
     * (from getMoreResults) There are no more results when the following is true:
     *
     * // stmt is a Statement object
     * ((stmt.getMoreResults() == false) &amp;&amp; (stmt.getUpdateCount() == -1))
     *
     * This is used by `getUpdateCount()`.  If there is a resultSet
     * then getUpdateCount will return -1.  If there is no result set, then, presumably,
     * `execute()` was called and we have one result and so can return something
     * other than -1 on the first call to getUpdateCount.   In this case, the second call to getUpdateCount
     * we should return -1;
     * We set this to zero on execute() and decrement it on getUpdateCount.  If the value of updateCount
     * is -1 then we just return it from getUpdateCount.
     */
    private var _updateCount = - 1
    private var poolable = false

    @Throws(SQLException::class)
    override fun addBatch(sql: String) {
        //sql must be a static sql
        sqlBatch.append(sql)
    }

    @Throws(SQLException::class)
    override fun cancel() {
        throw SQLFeatureNotSupportedException("cancel not supported")
    }

    @Throws(SQLException::class)
    override fun clearBatch() {
        sqlBatch = StringBuffer()
    }

    @Throws(SQLException::class)
    override fun clearWarnings() {
        // TODO Evaluate if the implementation is sufficient (if so, delete comment and log)
        Log.e(" ********************* not implemented @ " + fileName + " line " + lineNumber)
    }

    @Throws(SQLException::class)
    override fun close() {
        closeResultSet()
    }

    /** Close the result set (if open) and null the rs variable.  */
    @Throws(SQLException::class)
    fun closeResultSet() {
        if (rs != null) {
            if (! rs !!.isClosed) {
                rs !!.close()
            }
            rs = null
        }
    }

    @Throws(SQLException::class)
    /** Execute the SQL statement.
     * @return false if there are no result (if the request was not a select or similar).  True if a
     * result set is available.  This meets the requirement of java.sql.Statement.
     */
    override fun execute(sql: String): Boolean {
        _updateCount = - 1 // default outcome.  If the sql is a query or any other sql fails.
        closeResultSet()

        val isSelect = sql.uppercase(Locale.getDefault()).matches(selectPattern)
        if (isSelect) {
            val limitedSql = sql + if (maxRows != null) " LIMIT $maxRows" else ""
            val c = db.rawQuery(limitedSql, arrayOfNulls(0))
            rs = SQLDroidResultSet(c)
            if (c.count == 0) return false
        } else {
            db.execSQL(sql)
            rs = null
            _updateCount = sqldroidConnection.changedRowsCount()
        }
        return rs != null
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, autoGeneratedKeys: Int): Boolean {
        // TODO: Could be implemented like SQLDroidPreparedStatement
        throw SQLFeatureNotSupportedException("execute not supported - use executeUpdate or executeQuery")
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, columnIndexes: IntArray): Boolean {
        throw SQLFeatureNotSupportedException("execute not supported - use executeUpdate or executeQuery")
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, columnNames: Array<String>): Boolean {
        throw SQLFeatureNotSupportedException("execute not supported - use executeUpdate or executeQuery")
    }

    @Throws(SQLException::class)
    override fun executeBatch(): IntArray {
        _updateCount = - 1
        val results = IntArray(1)
        results[0] = Statement.EXECUTE_FAILED
        db.execSQL(sqlBatch.toString())
        results[0] = sqldroidConnection.changedRowsCount()
        _updateCount = results[0]
        return results
    }

    @Throws(SQLException::class)
    override fun executeQuery(sql: String): ResultSet {
        closeResultSet()
        val c = db.rawQuery(sql, null)
        rs = SQLDroidResultSet(c)
        return rs !!
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String): Int {
        closeResultSet()
        db.execSQL(sql)
        _updateCount = sqldroidConnection.changedRowsCount()
        return _updateCount
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String, autoGeneratedKeys: Int): Int {
        return executeUpdate(sql)
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String, columnIndexes: IntArray): Int {
        throw SQLFeatureNotSupportedException("executeUpdate(String,int[]) not supported - use executeUpdate(String)")
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String, columnNames: Array<String>): Int {
        throw SQLFeatureNotSupportedException("executeUpdate(String,String[]) not supported - use executeUpdate(String)")
    }

    @Throws(SQLException::class)
    override fun getConnection(): Connection {
        return sqldroidConnection
    }

    @Throws(SQLException::class)
    override fun getFetchDirection(): Int {
        // TODO Avoid NPE for rs
        return rs !!.fetchDirection
    }

    @Throws(SQLException::class)
    override fun getFetchSize(): Int {
        // TODO Avoid NPE for rs
        return rs !!.fetchSize
    }

    @Throws(SQLException::class)
    override fun getGeneratedKeys(): ResultSet {
        return sqldroidConnection.generatedRowIdResultSet
    }

    @Throws(SQLException::class)
    override fun getMaxFieldSize(): Int {
        return 0
    }

    @Throws(SQLException::class)
    override fun getMaxRows(): Int {
        // TODO: return rs.getMaxRows()
        // TODO: Avoid NPE for rs
        Log.e(
            " ********************* not implemented @ " + fileName + " line "
                    + lineNumber
        )
        return 0
    }

    @Throws(SQLException::class)
    override fun getMoreResults(): Boolean {
        return getMoreResults(Statement.CLOSE_CURRENT_RESULT)
    }

    @Throws(SQLException::class)
    override fun getMoreResults(current: Int): Boolean {
        if (current == Statement.CLOSE_CURRENT_RESULT) {
            closeResultSet()
        }
        return false
    }

    @Throws(SQLException::class)
    override fun getQueryTimeout(): Int {
        throw UnsupportedOperationException("getQueryTimeout not implemented yet")
    }

    @Throws(SQLException::class)
    override fun getResultSet(): ResultSet? {
        return rs
    }

    @Throws(SQLException::class)
    override fun getResultSetConcurrency(): Int {
        return ResultSet.CONCUR_READ_ONLY
    }

    @Throws(SQLException::class)
    override fun getResultSetHoldability(): Int {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT
    }

    @Throws(SQLException::class)
    override fun getResultSetType(): Int {
        return ResultSet.TYPE_FORWARD_ONLY
    }

    @Throws(SQLException::class)
    override fun getUpdateCount(): Int {
        if (_updateCount != - 1) {  // for any successful update/insert, update count will have been set
            // the documenation states that you're only supposed to call this once per result.
            // on subsequent calls, we'll return -1 (which would appear to be the correct return
            val tmp = _updateCount
            _updateCount = - 1
            return tmp
        }
        return _updateCount // if the result was a result set, or this is the second call, then this will be -1
    }

    @Throws(SQLException::class)
    override fun getWarnings(): SQLWarning? {
        // TODO Evaluate if the implementation is sufficient (if so, delete comment and log)
        Log.e(
            " ********************* not implemented @ " + fileName + " line "
                    + lineNumber
        )
        return null
    }

    @Throws(SQLException::class)
    override fun setCursorName(name: String) {
    }

    @Throws(SQLException::class)
    override fun setEscapeProcessing(enable: Boolean) {
        if (enable) {
            throw UnsupportedOperationException("setEscapeProcessing not implemented yet")
        }
    }

    @Throws(SQLException::class)
    override fun setFetchDirection(direction: Int) {
        // TODO: Avoid NPE
        rs !!.fetchDirection = direction
    }

    @Throws(SQLException::class)
    override fun setFetchSize(rows: Int) {
        // TODO: Avoid NPE
        rs !!.fetchSize = rows
    }

    @Throws(SQLException::class)
    override fun setMaxFieldSize(max: Int) {
        throw UnsupportedOperationException("Not implemented yet")
    }

    @Throws(SQLException::class)
    override fun setMaxRows(max: Int) {
        maxRows = if (isClosed) {
            throw SQLException("Statement is closed.")
        } else if (max < 0) {
            throw SQLException("Max rows must be zero or positive. Got $max")
        } else if (max == 0) {
            null
        } else {
            max
        }
    }

    @Throws(SQLException::class)
    override fun setQueryTimeout(seconds: Int) {
        throw UnsupportedOperationException("setQueryTimeout not implemented yet")
    }

    @Throws(SQLException::class)
    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface != null && iface.isAssignableFrom(javaClass)
    }

    @Throws(SQLException::class)
    override fun <T> unwrap(iface: Class<T>): T {
        if (isWrapperFor(iface)) {
            @Suppress("UNCHECKED_CAST")
            return this as T
        }
        throw SQLException("$javaClass does not wrap $iface")
    }

    @Throws(SQLException::class)
    override fun isClosed(): Boolean {
        return sqldroidConnection.isClosed
    }

    @Throws(SQLException::class)
    override fun isPoolable(): Boolean {
        return poolable
    }

    @Throws(SQLException::class)
    override fun setPoolable(poolable: Boolean) {
        this.poolable = poolable
    }

//    // methods added for JDK7 compilation
//    @Throws(SQLException::class)
//    override fun isCloseOnCompletion(): Boolean {
//        return false
//    }
//
//    @Throws(SQLException::class)
//    override fun closeOnCompletion() {
//        throw UnsupportedOperationException("closeOnCompletion not implemented yet")
//    }

    init {
        db = sqldroidConnection.db
    }
}