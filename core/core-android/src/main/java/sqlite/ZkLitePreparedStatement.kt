/*
 * Copyright Â© 2020-2021, Simplexion, Hungary and contributors. Use of this source code is governed by the Apache 2.0 license.
 */
package zakadabar.android.jdbc.sqlite

import java.io.*
import java.math.BigDecimal
import java.net.URL
import java.nio.charset.StandardCharsets
import java.sql.*
import java.sql.Date
import java.util.*

class ZkLitePreparedStatement(
    sql: String, sqldroid: ZkLiteConnection,
    /** The value used for autoGeneratedKeys in Connection.prepareStatement. Defaults to NO_GENERATED_KEYS
     */
    private val autoGeneratedKeys: Int
) : PreparedStatement {

    companion object {
        val selectPattern = Regex("(?m)(?s)\\s*SELECT.*")
        val createPattern = Regex("(?m)(?s)\\s*CREATE.*")
        val dropPattern = Regex("(?m)(?s)\\s*DROP.*")
        val pragmaPattern = Regex("(?m)(?s)\\s*PRAGMA.*")
    }

    protected var db: ZkLiteDatabase
    protected var sqldroidConnection: ZkLiteConnection
    protected var rs: ZkLiteResultSet? = null

    /**
     * @return the sql
     */
    var sQL: String? = null
        set(value) {
            // this is loosely based on the codee in SqlDroidStatement
            field = value
            if (value == null) {
                isSelect = false
                potentialResultSet = false
            } else {
                val sql = value.uppercase(Locale.getDefault())
                isSelect = sql.matches(selectPattern)
                potentialResultSet = true
                // examples of a failure on the next line (so isSelect is false and potentialResultSet remains true, are PRAGMA and INSERT (why INSERT?)
                if (! isSelect && (sql.matches(createPattern) || sql.matches(dropPattern))) {
                    potentialResultSet = false
                }
            }
        }

    protected val l = mutableListOf<Any?>()
    protected val lBatch = mutableListOf<MutableList<Any?>?>()
    private var maxRows: Int? = null

    /** True if the sql statement is a select.  */
    protected var isSelect = false

    /** True if the sql statement MAY produce a result set.  For example, "create" and "drop" command will
     * produce a "false" value for this.  */
    protected var potentialResultSet = false

    /** The update count.  We don't know this, but need to respond in such a way that:
     * (from getMoreResults) There are no more results when the following is true:
     *
     * // stmt is a Statement object
     * ((stmt.getMoreResults() == false) &amp;&amp; (stmt.getUpdateCount() == -1))
     *
     * This is used by `getUpdateCount()`.  If there is a resultSet
     * then getUpdateCount will return -1.  If there is no result set, then, presumably,
     * `execute()` was called and we have one result and so can return something
     * other than -1 on the first call to getUpdateCount.   In this case, the second call to getUpdateCount
     * we should return -1;
     * We set this to zero on execute() and decrement it on getUpdateCount.  If the value of updateCount
     * is -1 then we just return it from getUpdateCount.
     */
    private var updateCount = - 1

    /** The ResultSet object containing the last row id generated by the database when executing
     * an INSERT statement.
     */
    private var rowIdResultSet: ResultSet? = null
    private var poolable = false
    private var closed = false
    private fun ensureCap(@Suppress("UNUSED_PARAMETER") n: Int) {}
    private fun setObj(pn: Int, obj: Any?) {

        // prepared statements count from 1, we count from 0 (in array)
        val n = pn - 1

        // if arraylist is too small we add till it's grand enough
        // btw, why ain't there a l.setSize(n)?
        val additions = n - l.size + 1
        //System.out.println("adding " + additions + " elements");
        for (i in 0 until additions) {
            // System.out.println("ADD NULL");
            l.add(null)
        }

        //System.out.println("n = " + n + " size now " + l.size() + " we @ " + n);
        l[n] = obj
        //System.out.println("POST set n = " + n + " size now " + l.size() + " we @ " + n);
    }

    @Throws(SQLException::class)
    override fun addBatch(sql: String) {
        //sql must be a static sql
        sQL += sql
    }

    @Throws(SQLException::class)
    override fun cancel() {
        // TODO: This is simplemented by Xerial
        throw SQLFeatureNotSupportedException("cancel is not supported")
    }

    @Throws(SQLException::class)
    override fun clearBatch() {
        lBatch.clear()
    }

    @Throws(SQLException::class)
    override fun clearWarnings() {
        // TODO: Evaluate if implementation is sufficient (if so, delete comment and log)
        Log.e(
            " ********************* not implemented @ "
                    + fileName + " line "
                    + lineNumber
        )
    }

    @Throws(SQLException::class)
    override fun close() {
        closed = true
        try {
            if (rs != null) {
                rs !!.close()
            }
        } finally {
            rs = null
        }
    }

    private fun makeArgListQueryString(): Array<String?> {
        val ll = l
        if (ll.isNullOrEmpty()) {
            return arrayOfNulls(0)
        }
        // convert our parameter list objects to strings
        val strList: MutableList<String?> = ArrayList()
        for (o in ll) {
            strList.add(o.toString())
        }
        return strList.toTypedArray()
    }

    private fun makeArgListQueryObject(): Array<Any?> {
        return l.toTypedArray()
    }

    @Throws(SQLException::class)
    override fun execute(): Boolean {
        updateCount = - 1
        closeResultSet()
        // problem, a PRAGMA statement (and maybe others) should also cause a result set
        if (! isSelect && sQL !!.uppercase(Locale.getDefault()).matches(pragmaPattern)) {
            isSelect = true
        }
        if (isSelect) {
            val limitedSql = sQL + if (maxRows != null) " LIMIT $maxRows" else ""
            val c = db.rawQuery(limitedSql, makeArgListQueryString())
            rs = ZkLiteResultSet(c)
        } else {
            db.execSQL(sQL, makeArgListQueryObject())
            updateCount = sqldroidConnection.changedRowsCount()
        }
        return isSelect
    }

    /** Close the result set (if open) and null the rs variable.  */
    @Throws(SQLException::class)
    fun closeResultSet() {
        rs?.let {
            if (! it.isClosed) {
                it.close()
            }
            rs = null
        }
    }

    @Throws(SQLException::class)
    override fun executeQuery(): ResultSet? {
        updateCount = - 1
        closeResultSet()
        // Log.d("executeQuery " + sql);
        // when querying, all ? values must be converted to Strings for some reason
        val c = db.rawQuery(sQL, makeArgListQueryString())
        // Log.d("executeQuery " + 2);
        rs = ZkLiteResultSet(c)
        // Log.d("executeQuery " + 3 + ": " + rs);
        return rs
    }

    @Throws(SQLException::class)
    override fun executeUpdate(): Int {
        // TODO we can't count the actual number of updates .... :S
        execute()
        if (autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS) {
            // Capture the generated rowId immediately after executing the (insert) statement
            rowIdResultSet = sqldroidConnection.generatedRowIdResultSet
            return 1 // This should be more efficient than sqldroidConnection.changedRowsCount()
        }
        return updateCount
    }

    @Throws(SQLException::class)
    override fun execute(sql: String): Boolean {
        sQL = sql
        return execute()
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, autoGeneratedKeys: Int): Boolean {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, columnIndexes: IntArray): Boolean {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    @Throws(SQLException::class)
    override fun execute(sql: String, columnNames: Array<String>): Boolean {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    @Throws(SQLException::class)
    override fun executeBatch(): IntArray {
        val results = IntArray(lBatch.size)
        for (i in lBatch.indices) {
            updateCount = - 1
            results[i] = Statement.EXECUTE_FAILED
            db.execSQL(sQL, lBatch[i] !!.toTypedArray())
            results[i] = sqldroidConnection.changedRowsCount()
            updateCount = results[i]
        }
        return results
    }

    @Throws(SQLException::class)
    override fun executeQuery(sql: String): ResultSet? {
        sQL = sql
        return executeQuery()
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String): Int {
        sQL = sql
        return executeUpdate()
    }

    @Throws(SQLException::class)
    override fun executeUpdate(thisSql: String, autoGeneratedKeys: Int): Int {
        // System.out.println("sql in SQLDoidPreparedStatement.executeUpdate() is " + sql);
        db.execSQL(thisSql, makeArgListQueryObject())
        if (autoGeneratedKeys == PreparedStatement.RETURN_GENERATED_KEYS) {
            // Capture the generated rowId immediately after executing the (insert) statement
            rowIdResultSet = sqldroidConnection.generatedRowIdResultSet
            return 1 // This should be more efficient than sqldroidConnection.changedRowsCount()
        }
        return sqldroidConnection.changedRowsCount()
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String, columnIndexes: IntArray): Int {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    @Throws(SQLException::class)
    override fun executeUpdate(sql: String, columnNames: Array<String>): Int {
        throw SQLFeatureNotSupportedException("not implemented")
    }

    @Throws(SQLException::class)
    override fun getConnection(): Connection {
        return sqldroidConnection
    }

    @Throws(SQLException::class)
    override fun getFetchDirection(): Int {
        // TODO: Ensure that this doesn't throw NPE
        return rs !!.fetchDirection
    }

    @Throws(SQLException::class)
    override fun getFetchSize(): Int {
        // TODO: Ensure that this doesn't throw NPE
        return rs !!.fetchSize
    }

    @Throws(SQLException::class)
    override fun getGeneratedKeys(): ResultSet {
        val tmp = rowIdResultSet
        if (rowIdResultSet != null) {
            rowIdResultSet = null // so the next time it would be returned as null 	
        }
        return tmp !!
    }

    @Throws(SQLException::class)
    override fun getMaxFieldSize(): Int {
        return 0
    }

    @Throws(SQLException::class)
    override fun getMaxRows(): Int {
        return maxRows !!
    }

    @Throws(SQLException::class)
    /** There are no more results when the following is true:
     *
     * // stmt is a Statement object
     * ((stmt.getMoreResults() == false) && (stmt.getUpdateCount() == -1)) */
    override fun getMoreResults(): Boolean {
        return getMoreResults(Statement.CLOSE_CURRENT_RESULT)
    }

    @Throws(SQLException::class)
    override fun getMoreResults(current: Int): Boolean {
        if (current == Statement.CLOSE_CURRENT_RESULT) {
            closeResultSet()
        }
        return false
    }

    @Throws(SQLException::class)
    override fun getQueryTimeout(): Int {
        return 0
    }

    @Throws(SQLException::class)
    override fun getResultSet(): ResultSet? {
        return rs
    }

    @Throws(SQLException::class)
    override fun getResultSetConcurrency(): Int {
        return ResultSet.CONCUR_READ_ONLY
    }

    @Throws(SQLException::class)
    override fun getResultSetHoldability(): Int {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT
    }

    @Throws(SQLException::class)
    override fun getResultSetType(): Int {
        return ResultSet.TYPE_FORWARD_ONLY
    }

    /**Retrieves the current result as an update count; if the result is a ResultSet object or there are no more results, -1 is returned. This method should be called only once per result.
     * Returns:
     * the current result as an update count; -1 if the current result is a ResultSet object or there are no more results */
    @Throws(SQLException::class)
    override fun getUpdateCount(): Int {
        if (updateCount != - 1) {  // for any successful update/insert, update count will have been set
            // the documentation states that you're only supposed to call this once per result.
            // on subsequent calls, we'll return -1 (which would appear to be the correct return
            val tmp = updateCount
            updateCount = - 1
            return tmp
        }
        return updateCount // if the result was a result set, or this is the second call, then this will be -1
    }

    @Throws(SQLException::class)
    override fun getWarnings(): SQLWarning? {
        Log.e(
            " ********************* not implemented @ "
                    + fileName + " line "
                    + lineNumber
        )
        return null
    }

    @Throws(SQLException::class)
    override fun setCursorName(name: String) {
        throw SQLFeatureNotSupportedException("setCursorName not supported")
    }

    @Throws(SQLException::class)
    override fun setEscapeProcessing(enable: Boolean) {
        if (! enable) {
            throw UnsupportedOperationException("setEscapeProcessing not implemented yet")
        }
    }

    @Throws(SQLException::class)
    override fun setFetchDirection(direction: Int) {
        // TODO: Avoid NPE
        rs !!.fetchDirection = direction
    }

    @Throws(SQLException::class)
    override fun setFetchSize(rows: Int) {
        // TODO: Avoid NPE
        rs !!.fetchSize = rows
    }

    @Throws(SQLException::class)
    override fun setMaxFieldSize(max: Int) {
        throw UnsupportedOperationException("Not implemented yet")
    }

    @Throws(SQLException::class)
    override fun setMaxRows(max: Int) {
        ensureNotClosed()
        maxRows = if (max < 0) {
            throw SQLException("Max rows must be zero or positive. Got $max")
        } else if (max == 0) {
            null
        } else {
            max
        }
    }

    @Throws(SQLException::class)
    private fun ensureNotClosed() {
        if (isClosed) {
            throw SQLException("Statement is closed.")
        }
    }

    @Throws(SQLException::class)
    override fun setQueryTimeout(seconds: Int) {
        throw UnsupportedOperationException("setQueryTimeout not implemented")
    }

    @Throws(SQLException::class)
    override fun addBatch() {
        val n = lBatch.size
        lBatch.add(null)
        lBatch[n] = l
        clearParameters()
    }

    @Throws(SQLException::class)
    override fun clearParameters() {
        l.clear()
    }

    @Throws(SQLException::class)
    override fun getMetaData(): ResultSetMetaData {
        // TODO: Avoid NPE
        return rs !!.metaData
    }

    @Throws(SQLException::class)
    override fun getParameterMetaData(): ParameterMetaData {
        throw UnsupportedOperationException("getParameterMetaData not implemented")
    }

    @Throws(SQLException::class)
    override fun setArray(parameterIndex: Int, theArray: java.sql.Array) {
        throw SQLFeatureNotSupportedException("setArray not supported")
    }

    @Throws(SQLException::class)
    override fun setAsciiStream(parameterIndex: Int, theInputStream: InputStream, length: Int) {
        setAsciiStream(parameterIndex, theInputStream, length.toLong())
    }

    @Throws(SQLException::class)
    override fun setBigDecimal(parameterIndex: Int, theBigDecimal: BigDecimal) {
        setObject(parameterIndex, theBigDecimal.toString())
    }

    /**
     * Set the parameter from the contents of a binary stream.
     * @param parameterIndex the index of the parameter to set
     * @param inputStream the input stream from which a byte array will be read and set as the value.  If inputStream is null
     * this method will throw a SQLException
     * @param length a positive non-zero length values
     * @exception SQLException thrown if the length is &lt;= 0, the inputStream is null,
     * there is an IOException reading the inputStream or if "setBytes" throws a SQLException
     */
    @Throws(SQLException::class)
    override fun setBinaryStream(parameterIndex: Int, inputStream: InputStream?, length: Int) {
        if (length <= 0) {
            throw SQLException("Invalid length $length")
        }
        if (inputStream == null) {
            throw SQLException("Input Stream cannot be null")
        }
        val bufferSize = 8192
        val buffer = ByteArray(bufferSize)
        try {
            val outputStream = ByteArrayOutputStream()
            var bytesRemaining = length
            var bytesRead: Int
            var maxReadSize: Int
            while (bytesRemaining > 0) {
                maxReadSize = if (bytesRemaining > bufferSize) bufferSize else bytesRemaining
                bytesRead = inputStream.read(buffer, 0, maxReadSize)
                if (bytesRead == - 1) { // inputStream exhausted
                    break
                }
                outputStream.write(buffer, 0, bytesRead)
                bytesRemaining -= bytesRead
            }
            setBytes(parameterIndex, outputStream.toByteArray())
            outputStream.close()
        } catch (e: IOException) {
            throw SQLException(e.message)
        }
    }

    @Throws(SQLException::class)
    override fun setBlob(parameterIndex: Int, theBlob: Blob) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theBlob.getBytes(1, theBlob.length().toInt()))
    }

    @Throws(SQLException::class)
    override fun setBoolean(parameterIndex: Int, theBoolean: Boolean) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theBoolean)
    }

    @Throws(SQLException::class)
    override fun setByte(parameterIndex: Int, theByte: Byte) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theByte)
    }

    @Throws(SQLException::class)
    override fun setBytes(parameterIndex: Int, theBytes: ByteArray) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theBytes)
    }

    @Throws(SQLException::class)
    override fun setCharacterStream(parameterIndex: Int, reader: Reader, length: Int) {
        setCharacterStream(parameterIndex, reader, length.toLong())
    }

    @Throws(SQLException::class)
    override fun setClob(parameterIndex: Int, theClob: Clob) {
        ensureCap(parameterIndex)
        setString(parameterIndex, theClob.getSubString(1L, theClob.length().toInt()))
    }

    @Throws(SQLException::class)
    override fun setDate(parameterIndex: Int, theDate: Date?) {
        setTimestamp(parameterIndex, (if (theDate != null) Timestamp(theDate.time) else null) !!)
    }

    @Throws(SQLException::class)
    override fun setDate(parameterIndex: Int, theDate: Date?, cal: Calendar) {
        setTimestamp(parameterIndex, (if (theDate != null) Timestamp(theDate.time) else null) !!)
    }

    @Throws(SQLException::class)
    override fun setDouble(parameterIndex: Int, theDouble: Double) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theDouble)
    }

    @Throws(SQLException::class)
    override fun setFloat(parameterIndex: Int, theFloat: Float) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theFloat)
    }

    @Throws(SQLException::class)
    override fun setInt(parameterIndex: Int, theInt: Int) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theInt)
    }

    @Throws(SQLException::class)
    override fun setLong(parameterIndex: Int, theLong: Long) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theLong)
    }

    @Throws(SQLException::class)
    override fun setNull(parameterIndex: Int, sqlType: Int) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, null)
    }

    @Throws(SQLException::class)
    override fun setNull(paramIndex: Int, sqlType: Int, typeName: String) {
        ensureCap(paramIndex)
        setObj(paramIndex, null)
    }

    @Throws(SQLException::class)
    override fun setObject(parameterIndex: Int, theObject: Any?) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theObject)
    }

    @Throws(SQLException::class)
    override fun setObject(parameterIndex: Int, theObject: Any?, targetSqlType: Int) {
        setObject(parameterIndex, theObject)
    }

    @Throws(SQLException::class)
    override fun setObject(parameterIndex: Int, theObject: Any?, targetSqlType: Int, scale: Int) {
        setObj(parameterIndex, theObject)
    }

    @Throws(SQLException::class)
    override fun setRef(parameterIndex: Int, theRef: Ref) {
        throw SQLFeatureNotSupportedException("setRef not supported")
    }

    @Throws(SQLException::class)
    override fun setShort(parameterIndex: Int, theShort: Short) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theShort)
    }

    override fun setString(parameterIndex: Int, theString: String) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theString)
    }

    @Throws(SQLException::class)
    override fun setTime(parameterIndex: Int, theTime: Time) {
        // TODO: Test that this works
        setObject(parameterIndex, theTime)
    }

    @Throws(SQLException::class)
    override fun setTime(parameterIndex: Int, theTime: Time, cal: Calendar) {
        setTime(parameterIndex, theTime)
    }

    @Throws(SQLException::class)
    override fun setTimestamp(parameterIndex: Int, theTimestamp: Timestamp) {
        ensureCap(parameterIndex)
        setObj(parameterIndex, theTimestamp)
    }

    @Throws(SQLException::class)
    override fun setTimestamp(parameterIndex: Int, theTimestamp: Timestamp, cal: Calendar) {
        setTimestamp(parameterIndex, theTimestamp)
    }

    @Throws(SQLException::class)
    override fun setURL(parameterIndex: Int, theURL: URL) {
        throw SQLFeatureNotSupportedException("setURL not supported")
    }

    @Throws(SQLException::class)
    override fun setUnicodeStream(parameterIndex: Int, theInputStream: InputStream, length: Int) {
        setCharacterStream(parameterIndex, InputStreamReader(theInputStream, StandardCharsets.UTF_8), length)
    }

    @Throws(SQLException::class)
    override fun isClosed(): Boolean {
        // TODO Evaluate if this is a sufficient implementation
        return closed
    }

    @Throws(SQLException::class)
    override fun isPoolable(): Boolean {
        return poolable
    }

    @Throws(SQLException::class)
    override fun setPoolable(poolable: Boolean) {
        this.poolable = poolable
    }

    @Throws(SQLException::class)
    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface != null && iface.isAssignableFrom(javaClass)
    }

    @Throws(SQLException::class)
    override fun <T> unwrap(iface: Class<T>): T {
        if (isWrapperFor(iface)) {
            @Suppress("UNCHECKED_CAST")
            return this as T
        }
        throw SQLException("$javaClass does not wrap $iface")
    }

    @Throws(SQLException::class)
    override fun setAsciiStream(parameterIndex: Int, inputStream: InputStream) {
        setAsciiStream(parameterIndex, inputStream, - 1L)
    }

    @Throws(SQLException::class)
    override fun setAsciiStream(parameterIndex: Int, inputStream: InputStream, length: Long) {
        setCharacterStream(parameterIndex, InputStreamReader(inputStream, StandardCharsets.US_ASCII), length)
    }

    /** Read the byte stream and set the object as a byte[].  This is a pass through to
     * `setBinaryStream(parameterIndex, inputStream, Integer.MAX_VALUE);`
     * @see .setBinaryStream
     */
    @Throws(SQLException::class)
    override fun setBinaryStream(parameterIndex: Int, inputStream: InputStream) {
        setBinaryStream(parameterIndex, inputStream, Int.MAX_VALUE)
    }

    /** This is a pass through to the integer version of the same method.  That is, the long is downcast to an
     * integer.  If the length is greater than Integer.MAX_VALUE this method will throw a SQLException.
     * @see .setBinaryStream
     * @exception SQLException thrown if length is greater than Integer.MAX_VALUE or if there is a database error.
     */
    @Throws(SQLException::class)
    override fun setBinaryStream(parameterIndex: Int, inputStream: InputStream, length: Long) {
        if (length > Int.MAX_VALUE) {
            throw SQLException("SQLDroid does not allow input stream data greater than " + Int.MAX_VALUE)
        }
        setBinaryStream(parameterIndex, inputStream, length.toInt())
    }

    @Throws(SQLException::class)
    override fun setBlob(parameterIndex: Int, inputStream: InputStream) {
        setBlob(parameterIndex, inputStream, - 1)
    }

    @Throws(SQLException::class)
    override fun setBlob(parameterIndex: Int, inputStream: InputStream, length: Long) {
        // TODO setObject(parameterIndex, new SQLDroidBlob(inputStream, length));
        throw SQLFeatureNotSupportedException("setBlob not supported")
    }

    @Throws(SQLException::class)
    override fun setCharacterStream(parameterIndex: Int, reader: Reader) {
        setCharacterStream(parameterIndex, reader, - 1)
    }

    @Throws(SQLException::class)
    override fun setCharacterStream(parameterIndex: Int, reader: Reader, length: Long) {
        try {
            var intValueOfChar: Int
            val targetString = StringBuilder()
            while (reader.read().also { intValueOfChar = it } != - 1) {
                targetString.append(intValueOfChar.toChar())
            }
            setString(parameterIndex, targetString.toString())
        } catch (e: IOException) {
            throw SQLException("Failed to read reader.", e)
        }
    }

    @Throws(SQLException::class)
    override fun setClob(parameterIndex: Int, reader: Reader) {
        setClob(parameterIndex, reader, - 1)
    }

    @Throws(SQLException::class)
    override fun setClob(parameterIndex: Int, reader: Reader, length: Long) {
        // TODO setClob(parameterIndex, new SQLDroidClob(reader, length));
        throw SQLFeatureNotSupportedException("setClob not supported")
    }

    @Throws(SQLException::class)
    override fun setNCharacterStream(parameterIndex: Int, reader: Reader) {
        setNCharacterStream(parameterIndex, reader, - 1)
    }

    @Throws(SQLException::class)
    override fun setNCharacterStream(parameterIndex: Int, reader: Reader, length: Long) {
        setCharacterStream(parameterIndex, reader, length)
    }

    @Throws(SQLException::class)
    override fun setNClob(parameterIndex: Int, value: NClob) {
        throw SQLFeatureNotSupportedException("setNClob not supported")
    }

    @Throws(SQLException::class)
    override fun setNClob(parameterIndex: Int, reader: Reader) {
        setNClob(parameterIndex, reader, - 1)
    }

    @Throws(SQLException::class)
    override fun setNClob(parameterIndex: Int, reader: Reader, length: Long) {
        setClob(parameterIndex, reader, length)
    }

    @Throws(SQLException::class)
    override fun setNString(parameterIndex: Int, theString: String) {
        setString(parameterIndex, theString)
    }

    @Throws(SQLException::class)
    override fun setRowId(parameterIndex: Int, theRowId: RowId) {
        throw SQLFeatureNotSupportedException("setRowId not supported")
    }

    @Throws(SQLException::class)
    override fun setSQLXML(parameterIndex: Int, xmlObject: SQLXML) {
        throw SQLFeatureNotSupportedException("setSQLXML not supported")
    }

//    // methods added for JDK7 compilation
//    @Throws(SQLException::class)
//    override fun isCloseOnCompletion(): Boolean {
//        ensureNotClosed()
//        return false
//    }
//
//    @Throws(SQLException::class)
//    override fun closeOnCompletion() {
//        // TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
//    }

    init {
        Log.v("new SqlDroid prepared statement from $sqldroid")
        sqldroidConnection = sqldroid
        db = sqldroid.db
        sQL = sql
    }
}