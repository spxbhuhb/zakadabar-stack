/*
 * Copyright Â© 2020-2021, Simplexion, Hungary and contributors. Use of this source code is governed by the Apache 2.0 license.
 */
package zakadabar.android.jdbc.zklite

import android.database.SQLException
import java.io.File
import java.sql.*
import java.util.*

/** Connect to the database with the given url and properties.
 *
 * @param url the URL string, typically something like
 * "jdbc:sqlite:/data/data/your-package/databasefilename" so for example:
 * "jdbc:sqlite:/data/data/org.sqldroid.examples/databases/sqlite.db"
 * @param info Properties object with options.  Supported options are "timeout", "retry", and "shared".
 */
open class ZkLiteConnection(url: String, info: Properties?) : Connection {
    /** Returns the delegate SQLiteDatabase.  */
    /** The Android sqlitedb.  */
    val db: ZkLiteDatabase
    private var autoCommit = true

    /**
     * A cached prepare statement for the count of changed rows
     */
    private var changedRowsCountStatement: PreparedStatement? = null

    /**
     * A cached prepare statement for the last row id generated by the database
     */
    private var generatedRowIdStatement: PreparedStatement? = null
    private val url: String
    private var transactionIsolation = Connection.TRANSACTION_SERIALIZABLE

    private fun ensureDbFileCreation(dbQname: String) {
        val dbFile = File(dbQname)
        val parentFile = dbFile.parentFile
        when {
            dbFile.isDirectory -> {
                throw java.sql.SQLException("Can't create $dbFile - it already exists as a directory")
            }
            parentFile == null -> {
                throw java.sql.SQLException("Can't create $dbFile - it has no parent")
            }
            parentFile.exists() && ! parentFile.isDirectory -> {
                throw java.sql.SQLException("Can't create " + dbFile + " - it because " + dbFile.parent + " exists as a regular file")
            }
            ! parentFile.exists() -> {
                parentFile.mkdirs()
                if (! parentFile.isDirectory) {
                    throw java.sql.SQLException("Could not create " + dbFile.parent + " as parent directory for " + dbFile)
                }
            }
        }
    }

    override fun clearWarnings() {
    }

    override fun close() {
        ZkLiteLog.v("ZkLiteConnection.close(): " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)

        // FIXME check for duplicated close

        synchronized(dbMap) {
            clientMap.remove(this)
            if (! clientMap.containsValue(db)) {
                ZkLiteLog.i("ZkLiteConnection.close(): " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this + " Closing the database since since last connection was closed.")
                setAutoCommit(true)
                db.close()
                dbMap.remove(db.dbQname)
            }
        }

    }

    override fun commit() {
        if (autoCommit) {
            throw java.sql.SQLException("database in auto-commit mode")
        }
        db.setTransactionSuccessful()
        ZkLiteLog.d("END TRANSACTION  (commit) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
        db.endTransaction()
        ZkLiteLog.d("BEGIN TRANSACTION (after commit) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
        db.beginTransaction()
    }

    override fun createStatement(): Statement {
        return ZkLiteStatement(this)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement {
        return createStatement(resultSetType, resultSetConcurrency, ResultSet.CLOSE_CURSORS_AT_COMMIT)
    }

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): Statement {
        if (resultSetType != ResultSet.TYPE_FORWARD_ONLY) {
            throw SQLFeatureNotSupportedException("createStatement supported with TYPE_FORWARD_ONLY")
        }
        if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY) {
            throw SQLFeatureNotSupportedException("createStatement supported with CONCUR_READ_ONLY")
        }
        if (resultSetHoldability != ResultSet.CLOSE_CURSORS_AT_COMMIT) {
            throw SQLFeatureNotSupportedException("createStatement supported with CLOSE_CURSORS_AT_COMMIT")
        }
        return createStatement()
    }

    override fun getAutoCommit(): Boolean {
        return autoCommit
    }

    override fun getCatalog(): String? {
        return null
    }

    override fun getHoldability(): Int {
        return ResultSet.CLOSE_CURSORS_AT_COMMIT
    }

    override fun getMetaData(): DatabaseMetaData {
        return ZkLiteDatabaseMetaData(this)
    }

    override fun getTransactionIsolation(): Int {
        return transactionIsolation
    }

    override fun getTypeMap(): Map<String, Class<*>> {
        throw SQLFeatureNotSupportedException("getTypeMap not supported")
    }

    override fun getWarnings(): SQLWarning? {
        // TODO: Is this a sufficient implementation? (If so, delete comment and logging)
        ZkLiteLog.e(
            " ********************* not implemented @ " + fileName + " line "
                    + lineNumber
        )
        return null
    }

    override fun isClosed(): Boolean {
        // assuming that "isOpen" doesn't throw a locked exception..
        return db.sqliteDatabase?.isOpen == false
    }

    override fun isReadOnly(): Boolean {
        return false
    }

    override fun nativeSQL(sql: String): String {
        return sql
    }

    override fun prepareCall(sql: String): CallableStatement {
        return prepareCall(
            sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY,
            ResultSet.CLOSE_CURSORS_AT_COMMIT
        )
    }

    override fun prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int): CallableStatement {
        return prepareCall(
            sql, resultSetType, resultSetConcurrency,
            ResultSet.CLOSE_CURSORS_AT_COMMIT
        )
    }

    override fun prepareCall(
        sql: String, resultSetType: Int, resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): CallableStatement {
        throw SQLFeatureNotSupportedException("prepareCall not supported")
    }

    override fun prepareStatement(sql: String): PreparedStatement {
        return prepareStatement(sql, PreparedStatement.NO_GENERATED_KEYS)
    }

    override fun prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement {
        return ZkLitePreparedStatement(sql, this, autoGeneratedKeys)
    }

    override fun prepareStatement(sql: String, columnIndexes: IntArray): PreparedStatement {
        // this does not feel right, but xerial does the same
        return ZkLitePreparedStatement(sql, this, PreparedStatement.RETURN_GENERATED_KEYS)
    }

    override fun prepareStatement(sql: String, columnNames: Array<String>): PreparedStatement {
        // this does not feel right, but xerial does the same
        return ZkLitePreparedStatement(sql, this, PreparedStatement.RETURN_GENERATED_KEYS)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int): PreparedStatement {
        return prepareStatement(sql, resultSetType, resultSetConcurrency, ResultSet.CLOSE_CURSORS_AT_COMMIT)
    }

    override fun prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int): PreparedStatement {
        if (resultSetType != ResultSet.TYPE_FORWARD_ONLY) {
            throw SQLFeatureNotSupportedException("createStatement supported with TYPE_FORWARD_ONLY")
        }
        if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY) {
            throw SQLFeatureNotSupportedException("createStatement supported with CONCUR_READ_ONLY")
        }
        if (resultSetHoldability != ResultSet.CLOSE_CURSORS_AT_COMMIT) {
            throw SQLFeatureNotSupportedException("createStatement supported with CLOSE_CURSORS_AT_COMMIT")
        }
        return prepareStatement(sql)
    }

    override fun releaseSavepoint(savepoint: Savepoint) {
        // TODO: Implemented in Xerial as db.exec(String.format("RELEASE SAVEPOINT %s", savepoint.getSavepointName()));
        throw SQLFeatureNotSupportedException("releaseSavepoint not supported")
    }

    override fun rollback() {
        if (autoCommit) {
            throw java.sql.SQLException("database in auto-commit mode")
        }
        ZkLiteLog.d("END TRANSACTION (rollback) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
        db.endTransaction()
        ZkLiteLog.d("BEGIN TRANSACTION (after rollback) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
        db.beginTransaction()
    }

    override fun rollback(savepoint: Savepoint) {
        // TODO: Implemented in Xerial as db.exec(String.format("ROLLBACK TO SAVEPOINT %s", savepoint.getSavepointName()));
        throw SQLFeatureNotSupportedException("rollback not supported")
    }

    override fun setAutoCommit(autoCommit: Boolean) {
        if (this.autoCommit == autoCommit) {
            return
        }
        this.autoCommit = autoCommit
        if (autoCommit) {
            if (db.inTransaction()) { // to be on safe side.
                db.setTransactionSuccessful()
                ZkLiteLog.d("END TRANSACTION (autocommit on) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
                db.endTransaction()
            }
        } else {
            ZkLiteLog.d("BEGIN TRANSACTION (autocommit off) " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
            db.beginTransaction()
        }
    }

    override fun setCatalog(catalog: String) {
        // From spec:
        // If the driver does not support catalogs, it will silently ignore this request.
    }

    override fun setHoldability(holdability: Int) {
        if (holdability != ResultSet.CLOSE_CURSORS_AT_COMMIT) throw java.sql.SQLException("ZkLite only supports CLOSE_CURSORS_AT_COMMIT")
    }

    override fun setReadOnly(readOnly: Boolean) {
        if (readOnly != isReadOnly) {
            throw java.sql.SQLException("Cannot change read-only flag after establishing a connection")
        }
    }

    override fun setSavepoint(): Savepoint {
        // TODO: In Xerial: db.exec(String.format("SAVEPOINT %s", sp.getSavepointName()))
        throw SQLFeatureNotSupportedException("setSavepoint not supported")
    }

    override fun setSavepoint(name: String): Savepoint {
        throw SQLFeatureNotSupportedException("setSavepoint not supported")
    }

    override fun setTransactionIsolation(level: Int) {
        // TODO: Xerial implements this with PRAGMA read_uncommitted
        if (level != Connection.TRANSACTION_SERIALIZABLE) {
            throw java.sql.SQLException("ZkLite supports only TRANSACTION_SERIALIZABLE.")
        }
        transactionIsolation = level
    }

    override fun setTypeMap(arg0: Map<String?, Class<*>?>?) {
        throw SQLFeatureNotSupportedException("setTypeMap not supported")
    }

    override fun isWrapperFor(iface: Class<*>?): Boolean {
        return iface != null && iface.isAssignableFrom(javaClass)
    }

    override fun <T> unwrap(iface: Class<T>): T {
        if (isWrapperFor(iface)) {
            @Suppress("UNCHECKED_CAST") // isWrapperFor checks it
            return this as T
        }
        throw java.sql.SQLException("$javaClass does not wrap $iface")
    }

    override fun createArrayOf(typeName: String, elements: Array<Any>): java.sql.Array {
        throw SQLFeatureNotSupportedException("createArrayOf not supported")
    }

    override fun createBlob(): Blob {
        // TODO: Can return new ZkLiteBlob(new byte[0]) once setBytes is implemented
        throw SQLFeatureNotSupportedException("createBlob not supported")
    }

    override fun createClob(): ZkLiteClob {
        // TODO: Can return new ZkLiteClob("") once setString is implemented
        throw SQLFeatureNotSupportedException("createClob not supported")
    }

    override fun createNClob(): NClob {
        return createClob()
    }

    override fun createSQLXML(): SQLXML {
        throw SQLFeatureNotSupportedException("createSQLXML not supported")
    }

    override fun createStruct(typeName: String, attributes: Array<Any>): Struct {
        throw SQLFeatureNotSupportedException("createStruct not supported")
    }

    override fun getClientInfo(): Properties {
        // TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
        return Properties()
    }

    override fun getClientInfo(name: String): String? {
        // TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
        return null
    }

    override fun isValid(timeout: Int): Boolean {
        // TODO createStatement().execute("select 1");
        return true
    }

    @Throws(SQLClientInfoException::class)
    override fun setClientInfo(properties: Properties) {
        // TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
    }

    @Throws(SQLClientInfoException::class)
    override fun setClientInfo(name: String, value: String) {
        // TODO Evaluate if this is a sufficient implementation (if so, remove this comment)
    }

    /**
     * @return Where the database is located.
     */
    fun url(): String {
        return url
    }

//    // methods added for JDK7 compilation
////    override fun setNetworkTimeout(executor: Executor, milliseconds: Int) {
//        throw SQLFeatureNotSupportedException("setNetworkTimeout not supported")
//    }
//
////    override fun getNetworkTimeout(): Int {
//        throw SQLFeatureNotSupportedException("getNetworkTimeout not supported")
//    }
//
////    override fun abort(executor: Executor) {
//        close()
//    }
//
////    override fun getSchema(): String? {
//        return null
//    }
//
////    override fun setSchema(schema: String) {
//    }

    /**
     * @return The number of database rows that were changed or inserted or deleted
     * by the most recently completed INSERT, DELETE, or UPDATE statement.
     */
    fun changedRowsCount(): Int {
        var changedRows = - 1
        try {
            changedRowsCountStatement = getChangedRowsCountStatement()
            val changedRowsCountResultSet = changedRowsCountStatement !!.executeQuery()
            if (changedRowsCountResultSet != null && changedRowsCountResultSet.first()) {
                changedRows = changedRowsCountResultSet.getLong(1).toInt()
                // System.out.println("In ZkLiteConnection.changedRowsCount(), changedRows=" + changedRows);
            }
            changedRowsCountResultSet !!.close()
        } catch (e: java.sql.SQLException) {
            // ignore
        }
        return changedRows
    }

    /**
     * @return A cached prepare statement for the last row id generated
     * by the database when executing an INSERT statement or create a
     * new prepare statement and then return that.
     *
     * @throws SQLException
     */
    @get:Throws(java.sql.SQLException::class)
    val generatedRowIdResultSet: ResultSet
        get() {
            if (generatedRowIdStatement == null) {
                generatedRowIdStatement = prepareStatement("select last_insert_rowid() as id;")
            }
            return generatedRowIdStatement !!.executeQuery()
        }

    /**
     * @return A cached prepare statement for the count of changed rows or create one and return that.
     *
     * @throws SQLException
     */
    private fun getChangedRowsCountStatement(): PreparedStatement? {
        if (changedRowsCountStatement == null) {
            changedRowsCountStatement = prepareStatement("select changes();")
        }
        return changedRowsCountStatement
    }

    companion object {
        /**
         * A map to a single instance of a SQLiteDatabase per DB.
         */
        private val dbMap: MutableMap<String?, ZkLiteDatabase> = HashMap()

        /**
         * A map from a connection to a SQLiteDatabase instance.
         * Used to track the use of each instance, and close the database when last conneciton is closed.
         */
        private val clientMap: MutableMap<ZkLiteConnection, ZkLiteDatabase> = HashMap()

        /** Will have the value 9 or greater the version of SQLException has the constructor:
         * SQLException(Throwable theCause) otherwise false.
         * API levels 9 or greater have this constructor.
         * If the value is positive and less than 9 then the SQLException does not have the constructor.
         * If the value is &lt; 0 then the capabilities of SQLException have not been determined.
         */
        var sqlThrowable = - 1

        /** This will create and return an exception.
         */
        fun chainException(sqlException: SQLException): java.sql.SQLException {
            if (sqlThrowable < 0 || sqlThrowable >= 9) {
                try {
                    sqlThrowable = 9
                    //return new SQLException (sqlException);
                    // creating by reflection is significantly slower, but since Exceptions should be unusual
                    // this should not be a performance issue.
                    return SQLException(sqlException)
                } catch (e: Exception) {
                    sqlThrowable = 1
                }
            }
            // if the code above worked correctly, then the exception will have been returned.  Otherwise, we need
            // to go through this clause and create a ZkLiteSQLException
            return try {
                SQLException(sqlException)
            } catch (e: Exception) {
                java.sql.SQLException("Unable to Chain SQLException " + sqlException.message)
            }
        }
    }

    init {
        ZkLiteLog.v("ZkLiteConnection: " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this)
        ZkLiteLog.v("New sqlite jdbc from url '$url', '$info'")
        this.url = url
        // Make a filename from url
        var dbQname = url.substring(ZkLiteDriver.zkLitePrefix.length)
        var timeout: Long = 0 // default to no retries to be consistent with other JDBC implemenations.
        var retryInterval: Long = 50 // this was 1000 in the original code.  1 second is too long for each loop.
        val queryPart = dbQname.indexOf('?')

        // if there's a query part, we accept "timeout=xxx" and "retry=yyy"
        if (queryPart > 0) {
            dbQname = dbQname.substring(0, queryPart)
            var options = dbQname.substring(queryPart)
            while (options.isNotEmpty()) {
                var optionEnd = options.indexOf('&')
                if (optionEnd == - 1) {
                    optionEnd = options.length
                }
                val equals = options.lastIndexOf('=', optionEnd)
                val optionName = options.substring(0, equals).trim { it <= ' ' }
                val optionValueString = options.substring(equals + 1, optionEnd).trim { it <= ' ' }
                var optionValue: Long
                try {
                    optionValue = optionValueString.toLong()
                    if (optionName == "timeout") {
                        timeout = optionValue
                    } else if (optionName == "retry") {
                        timeout = optionValue
                        retryInterval = optionValue
                    }
                    ZkLiteLog.v("Timeout: $timeout")
                } catch (nfe: NumberFormatException) {
                    // print and ignore
                    ZkLiteLog.e("Error Parsing URL \"$url\" Timeout String \"$optionValueString\" is not a valid long", nfe)
                }
                options = options.substring(optionEnd + 1)
            }
        }
        ZkLiteLog.v("opening database $dbQname")
        ensureDbFileCreation(dbQname)
        var flags = (android.database.sqlite.SQLiteDatabase.CREATE_IF_NECESSARY
                or android.database.sqlite.SQLiteDatabase.OPEN_READWRITE
                or android.database.sqlite.SQLiteDatabase.NO_LOCALIZED_COLLATORS)
        if (info != null) {
            if (info.getProperty(ZkLiteDriver.DATABASE_FLAGS) != null) {
                try {
                    flags = info.getProperty(ZkLiteDriver.DATABASE_FLAGS).toInt()
                } catch (nfe: NumberFormatException) {
                    ZkLiteLog.e("Error Parsing DatabaseFlags \"" + info.getProperty(ZkLiteDriver.DATABASE_FLAGS) + " not a number ", nfe)
                }
            } else if (info.getProperty(ZkLiteDriver.ADDITONAL_DATABASE_FLAGS) != null) {
                try {
                    val extraFlags = info.getProperty(ZkLiteDriver.ADDITONAL_DATABASE_FLAGS).toInt()
                    flags = flags or extraFlags
                } catch (nfe: NumberFormatException) {
                    ZkLiteLog.e("Error Parsing DatabaseFlags \"" + info.getProperty(ZkLiteDriver.ADDITONAL_DATABASE_FLAGS) + " not a number ", nfe)
                }
            }
        }
        synchronized(dbMap) {
            var cdb = dbMap[dbQname]
            if (cdb == null) {
                ZkLiteLog.i("ZkLiteConnection: " + Thread.currentThread().id + " \"" + Thread.currentThread().name + "\" " + this + " Opening new database: " + dbQname)
                cdb = ZkLiteDatabase(dbQname, timeout, retryInterval, flags)
                dbMap[dbQname] = cdb
            }
            clientMap.put(this, cdb)
            db = cdb
        }
    }
}